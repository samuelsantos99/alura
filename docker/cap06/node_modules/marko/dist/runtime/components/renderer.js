var componentsUtil = require("@internal/components-util");
var componentLookup = componentsUtil._n_;

var ComponentsContext = require("./ComponentsContext");
var getComponentsContext = ComponentsContext.U_;
var registry = require("@internal/components-registry");
var copyProps = require("raptor-util/copyProps");
var isServer = componentsUtil._J_ === true;
var beginComponent = require("@internal/components-beginComponent");
var endComponent = require("@internal/components-endComponent");

var COMPONENT_BEGIN_ASYNC_ADDED_KEY = "$wa";

function resolveComponentKey(key, parentComponentDef) {
  if (key[0] === "#") {
    return key.substring(1);
  } else {
    return parentComponentDef.id + "-" + parentComponentDef.aN_(key);
  }
}

function trackAsyncComponents(out) {
  if (out.isSync() || out.global[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {
    return;
  }

  out.on("beginAsync", handleBeginAsync);
  out.on("beginDetachedAsync", handleBeginDetachedAsync);
  out.global[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;
}

function handleBeginAsync(event) {
  var parentOut = event.parentOut;
  var asyncOut = event.out;
  var componentsContext = parentOut.t_;

  if (componentsContext !== undefined) {
    // We are going to start a nested ComponentsContext
    asyncOut.t_ = new ComponentsContext(asyncOut, componentsContext);
  }
  // Carry along the component arguments
  asyncOut.c(parentOut.aa_, parentOut.ab_, parentOut.bc_);
}

function handleBeginDetachedAsync(event) {
  var asyncOut = event.out;
  handleBeginAsync(event);
  asyncOut.on("beginAsync", handleBeginAsync);
  asyncOut.on("beginDetachedAsync", handleBeginDetachedAsync);
}

function createRendererFunc(templateRenderFunc, componentProps, renderingLogic) {
  var onInput = renderingLogic && renderingLogic.onInput;
  var typeName = componentProps.e_;
  var isSplit = componentProps.c_ === true;
  var isImplicitComponent = componentProps.d_ === true;

  var shouldApplySplitMixins = renderingLogic && isSplit;

  return function renderer(input, out) {
    trackAsyncComponents(out);

    var componentsContext = getComponentsContext(out);
    var globalComponentsContext = componentsContext.r_;

    var component = globalComponentsContext.aB_;
    var isRerender = component !== undefined;
    var id;
    var isExisting;
    var customEvents;
    var parentComponentDef = componentsContext.q_;
    var ownerComponentDef = out.aa_;
    var ownerComponentId = ownerComponentDef && ownerComponentDef.id;
    var key = out.ab_;

    if (component) {
      // If component is provided then we are currently rendering
      // the top-level UI component as part of a re-render
      id = component.id; // We will use the ID of the component being re-rendered
      isExisting = true; // This is a re-render so we know the component is already in the DOM
      globalComponentsContext.aB_ = null;
    } else {
      // Otherwise, we are rendering a nested UI component. We will need
      // to match up the UI component with the component already in the
      // DOM (if any) so we will need to resolve the component ID from
      // the assigned key. We also need to handle any custom event bindings
      // that were provided.
      if (parentComponentDef) {
        // console.log('componentArgs:', componentArgs);
        customEvents = out.bc_;

        if (key != null) {
          id = resolveComponentKey(key.toString(), parentComponentDef);
        } else {
          id = parentComponentDef.aO_();
        }
      } else {
        id = globalComponentsContext.aO_();
      }
    }

    if (isServer) {
      // If we are rendering on the server then things are simplier since
      // we don't need to match up the UI component with a previously
      // rendered component already mounted to the DOM. We also create
      // a lightweight ServerComponent
      component = registry._G_(renderingLogic, id, input, out, typeName, customEvents, ownerComponentId);

      // This is the final input after running the lifecycle methods.
      // We will be passing the input to the template for the `input` param
      input = component._b_;
    } else {
      if (!component) {
        if (isRerender && (component = componentLookup[id]) && component.e_ !== typeName) {
          // Destroy the existing component since
          component.destroy();
          component = undefined;
        }

        if (component) {
          isExisting = true;
        } else {
          isExisting = false;
          // We need to create a new instance of the component
          component = registry._G_(typeName, id);

          if (shouldApplySplitMixins === true) {
            shouldApplySplitMixins = false;

            var renderingLogicProps = typeof renderingLogic == "function" ? renderingLogic.prototype : renderingLogic;

            copyProps(renderingLogicProps, component.constructor.prototype);
          }
        }

        // Set this flag to prevent the component from being queued for update
        // based on the new input. The component is about to be rerendered
        // so we don't want to queue it up as a result of calling `setInput()`
        component._c_ = true;

        if (customEvents !== undefined) {
          component.aE_(customEvents, ownerComponentId);
        }

        if (isExisting === false) {
          component.aG_(input, out);
        }

        input = component._l_(input, onInput, out);

        if (isExisting === true) {
          if (component.aw_ === false || component.shouldUpdate(input, component.C_) === false) {
            // We put a placeholder element in the output stream to ensure that the existing
            // DOM node is matched up correctly when using morphdom. We flag the VElement
            // node to track that it is a preserve marker
            out.bd_(component);
            globalComponentsContext.s_[id] = true;
            component._t_(); // The component is no longer dirty so reset internal flags
            return;
          }
        }
      }

      component.am_ = out.global;
      component.aH_(out);
    }

    var componentDef = beginComponent(componentsContext, component, key, ownerComponentDef, isSplit, isImplicitComponent);

    componentDef._u_ = isExisting;

    // Render the template associated with the component using the final template
    // data that we constructed
    templateRenderFunc(input, out, componentDef, component, component.aD_);

    endComponent(out, componentDef);
    componentsContext.q_ = parentComponentDef;
  };
}

module.exports = createRendererFunc;

// exports used by the legacy renderer
createRendererFunc.aX_ = resolveComponentKey;
createRendererFunc.bb_ = trackAsyncComponents;