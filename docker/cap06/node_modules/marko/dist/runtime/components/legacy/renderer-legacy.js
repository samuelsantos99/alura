var getComponentsContext = require("../ComponentsContext").U_;
var componentsUtil = require("@internal/components-util");
var componentLookup = componentsUtil._n_;
var registry = require("@internal/components-registry");
var modernRenderer = require("../renderer");
var resolveComponentKey = modernRenderer.aX_;
var trackAsyncComponents = modernRenderer.bb_;
var beginComponent = require("@internal/components-beginComponent");
var endComponent = require("@internal/components-endComponent");
var complain;

function createRendererFunc(templateRenderFunc, componentProps) {
  var typeName = componentProps.e_;
  //var assignedId = componentProps.id;
  var isSplit = componentProps.c_ === true;

  return function renderer(input, out, assignedId, renderingLogic) {
    trackAsyncComponents(out);

    var widgetBody = input.renderBody;
    var widgetState = input.widgetState;
    var widgetConfig = input.widgetConfig;

    var componentsContext = getComponentsContext(out);
    var globalComponentsContext = componentsContext.r_;

    var component = globalComponentsContext.aB_;

    var isRerender = component !== undefined;
    var id = assignedId;
    var isExisting;
    var parentComponentDef = componentsContext.q_;
    var ownerComponentDef = out.aa_;
    var ownerComponentId = ownerComponentDef && ownerComponentDef.id;
    var key = out.ab_;
    var customEvents = out.bc_;

    out.aa_ = null;

    if (component) {
      id = component.id;
      isExisting = true;
      globalComponentsContext.aB_ = null;
    } else {
      if (key != null) {
        id = id || resolveComponentKey(key.toString(), parentComponentDef);
      } else if (parentComponentDef) {
        id = parentComponentDef.aO_();
      } else {
        id = globalComponentsContext.aO_();
      }
    }

    if (registry._J_ && typeName) {
      if (renderingLogic) delete renderingLogic.onRender;
      component = registry._G_(renderingLogic, id, input, out, typeName, customEvents, ownerComponentId);
      if (isSplit || widgetState) {
        component.input = null;
      } else if (input.widgetProps) {
        component.input = input.widgetProps;
        // eslint-disable-next-line no-constant-condition
      }
    } else {
      if (!component) {
        if (isRerender) {
          // Look in in the DOM to see if a component with the same ID and type already exists.
          component = componentLookup[id];
          if (component && component.e_ !== typeName) {
            component = undefined;
          }
        }

        if (component) {
          isExisting = true;
        } else {
          isExisting = false;
          // We need to create a new instance of the component
          if (typeName) {
            component = registry._G_(typeName, id);
          }
        }
      }
    }

    var isFakeComponent = false;

    if (!component) {
      isFakeComponent = true;
      component = {
        id: id,
        N_: {}
      };
    } else {
      component._c_ = true;

      if (widgetState) {
        component.state = widgetState;
      }
    }

    component.widgetConfig = widgetConfig;
    component.___ = widgetBody || component.___;

    var componentDef = beginComponent(componentsContext, component, key, ownerComponentDef, isSplit, isFakeComponent);
    var parentLegacyComponentDef = componentsContext.ba_;
    componentsContext.ba_ = componentDef;

    // This is a hack, but we have to swap out the component instance stored with this node
    var vComponentNode = out.ac_;

    componentDef.v_ = isFakeComponent ? null : component;
    componentDef._u_ = isExisting;
    componentDef.B_ = true;

    componentDef.t = function (typeName) {
      if (typeName) {
        if (registry._J_) {
          var oldComponent = component;
          if (renderingLogic) delete renderingLogic.onRender;
          component = registry._G_(renderingLogic || {}, id, input, out, typeName, customEvents, ownerComponentId);
          if (isSplit || widgetState) {
            component.input = null;
          } else if (input.widgetProps) {
            component.input = input.widgetProps;
            // eslint-disable-next-line no-constant-condition
          }
          Object.assign(component, oldComponent);
          beginComponent(componentsContext, component, key, ownerComponentDef, isSplit, false, this);
        } else {
          vComponentNode.v_ = component = registry._G_(typeName, component.id);
        }
        this.v_ = component;
      }
    };

    if (!registry._J_) {
      component.O_ && component.O_();
    }

    // Render the template associated with the component using the final template
    // data that we constructed
    templateRenderFunc(input, out, componentDef, componentDef, component);

    if (customEvents && componentDef.v_) {
      if (registry._J_) {
        componentDef.X_ = customEvents;
        componentDef.Y_ = ownerComponentId;
      } else {
        componentDef.v_.aE_(customEvents, ownerComponentId);
      }
    }

    endComponent(out, componentDef);
    componentsContext.q_ = parentComponentDef;
    componentsContext.ba_ = parentLegacyComponentDef;
  };
}

module.exports = createRendererFunc;